{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FluxStore\n * \n */\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nvar _require = require('fbemitter');\n\nvar EventEmitter = _require.EventEmitter;\n\nvar invariant = require('fbjs/lib/invariant');\n/**\n * This class represents the most basic functionality for a FluxStore. Do not\n * extend this store directly; instead extend FluxReduceStore when creating a\n * new store.\n */\n\n\nvar FluxStore = function () {\n  function FluxStore(dispatcher) {\n    var _this = this;\n\n    _classCallCheck(this, FluxStore);\n\n    this.__className = this.constructor.name;\n    this.__changed = false;\n    this.__changeEvent = 'change';\n    this.__dispatcher = dispatcher;\n    this.__emitter = new EventEmitter();\n    this._dispatchToken = dispatcher.register(function (payload) {\n      _this.__invokeOnDispatch(payload);\n    });\n  }\n\n  FluxStore.prototype.addListener = function addListener(callback) {\n    return this.__emitter.addListener(this.__changeEvent, callback);\n  };\n\n  FluxStore.prototype.getDispatcher = function getDispatcher() {\n    return this.__dispatcher;\n  };\n  /**\n   * This exposes a unique string to identify each store's registered callback.\n   * This is used with the dispatcher's waitFor method to declaratively depend\n   * on other stores updating themselves first.\n   */\n\n\n  FluxStore.prototype.getDispatchToken = function getDispatchToken() {\n    return this._dispatchToken;\n  };\n  /**\n   * Returns whether the store has changed during the most recent dispatch.\n   */\n\n\n  FluxStore.prototype.hasChanged = function hasChanged() {\n    !this.__dispatcher.isDispatching() ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.hasChanged(): Must be invoked while dispatching.', this.__className) : invariant(false) : undefined;\n    return this.__changed;\n  };\n\n  FluxStore.prototype.__emitChange = function __emitChange() {\n    !this.__dispatcher.isDispatching() ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.__emitChange(): Must be invoked while dispatching.', this.__className) : invariant(false) : undefined;\n    this.__changed = true;\n  };\n  /**\n   * This method encapsulates all logic for invoking __onDispatch. It should\n   * be used for things like catching changes and emitting them after the\n   * subclass has handled a payload.\n   */\n\n\n  FluxStore.prototype.__invokeOnDispatch = function __invokeOnDispatch(payload) {\n    this.__changed = false;\n\n    this.__onDispatch(payload);\n\n    if (this.__changed) {\n      this.__emitter.emit(this.__changeEvent);\n    }\n  };\n  /**\n   * The callback that will be registered with the dispatcher during\n   * instantiation. Subclasses must override this method. This callback is the\n   * only way the store receives new data.\n   */\n\n\n  FluxStore.prototype.__onDispatch = function __onDispatch(payload) {\n    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s has not overridden FluxStore.__onDispatch(), which is required', this.__className) : invariant(false) : undefined;\n  };\n\n  return FluxStore;\n}();\n\nmodule.exports = FluxStore; // private\n// protected, available to subclasses","map":{"version":3,"sources":["/Users/jeffreyigims/Documents/survey/node_modules/flux/lib/FluxStore.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_require","require","EventEmitter","invariant","FluxStore","dispatcher","_this","__className","constructor","name","__changed","__changeEvent","__dispatcher","__emitter","_dispatchToken","register","payload","__invokeOnDispatch","prototype","addListener","callback","getDispatcher","getDispatchToken","hasChanged","isDispatching","process","env","NODE_ENV","undefined","__emitChange","__onDispatch","emit","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FluxStore\n * \n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _require = require('fbemitter');\n\nvar EventEmitter = _require.EventEmitter;\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * This class represents the most basic functionality for a FluxStore. Do not\n * extend this store directly; instead extend FluxReduceStore when creating a\n * new store.\n */\n\nvar FluxStore = (function () {\n  function FluxStore(dispatcher) {\n    var _this = this;\n\n    _classCallCheck(this, FluxStore);\n\n    this.__className = this.constructor.name;\n\n    this.__changed = false;\n    this.__changeEvent = 'change';\n    this.__dispatcher = dispatcher;\n    this.__emitter = new EventEmitter();\n    this._dispatchToken = dispatcher.register(function (payload) {\n      _this.__invokeOnDispatch(payload);\n    });\n  }\n\n  FluxStore.prototype.addListener = function addListener(callback) {\n    return this.__emitter.addListener(this.__changeEvent, callback);\n  };\n\n  FluxStore.prototype.getDispatcher = function getDispatcher() {\n    return this.__dispatcher;\n  };\n\n  /**\n   * This exposes a unique string to identify each store's registered callback.\n   * This is used with the dispatcher's waitFor method to declaratively depend\n   * on other stores updating themselves first.\n   */\n\n  FluxStore.prototype.getDispatchToken = function getDispatchToken() {\n    return this._dispatchToken;\n  };\n\n  /**\n   * Returns whether the store has changed during the most recent dispatch.\n   */\n\n  FluxStore.prototype.hasChanged = function hasChanged() {\n    !this.__dispatcher.isDispatching() ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.hasChanged(): Must be invoked while dispatching.', this.__className) : invariant(false) : undefined;\n    return this.__changed;\n  };\n\n  FluxStore.prototype.__emitChange = function __emitChange() {\n    !this.__dispatcher.isDispatching() ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.__emitChange(): Must be invoked while dispatching.', this.__className) : invariant(false) : undefined;\n    this.__changed = true;\n  };\n\n  /**\n   * This method encapsulates all logic for invoking __onDispatch. It should\n   * be used for things like catching changes and emitting them after the\n   * subclass has handled a payload.\n   */\n\n  FluxStore.prototype.__invokeOnDispatch = function __invokeOnDispatch(payload) {\n    this.__changed = false;\n    this.__onDispatch(payload);\n    if (this.__changed) {\n      this.__emitter.emit(this.__changeEvent);\n    }\n  };\n\n  /**\n   * The callback that will be registered with the dispatcher during\n   * instantiation. Subclasses must override this method. This callback is the\n   * only way the store receives new data.\n   */\n\n  FluxStore.prototype.__onDispatch = function __onDispatch(payload) {\n    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s has not overridden FluxStore.__onDispatch(), which is required', this.__className) : invariant(false) : undefined;\n  };\n\n  return FluxStore;\n})();\n\nmodule.exports = FluxStore;\n\n// private\n\n// protected, available to subclasses"]},"metadata":{},"sourceType":"script"}