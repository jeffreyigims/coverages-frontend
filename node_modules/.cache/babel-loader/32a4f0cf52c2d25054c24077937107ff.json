{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FluxMixinLegacy\n * \n */\n'use strict';\n\nvar FluxStoreGroup = require('./FluxStoreGroup');\n\nvar invariant = require('fbjs/lib/invariant');\n/**\n * `FluxContainer` should be preferred over this mixin, but it requires using\n * react with classes. So this mixin is provided where it is not yet possible\n * to convert a container to be a class.\n *\n * This mixin should be used for React components that have state based purely\n * on stores. `this.props` will not be available inside of `calculateState()`.\n *\n * This mixin will only `setState` not replace it, so you should always return\n * every key in your state unless you know what you are doing. Consider this:\n *\n *   var Foo = React.createClass({\n *     mixins: [\n *       FluxMixinLegacy([FooStore])\n *     ],\n *\n *     statics: {\n *       calculateState(prevState) {\n *         if (!prevState) {\n *           return {\n *             foo: FooStore.getFoo(),\n *           };\n *         }\n *\n *         return {\n *           bar: FooStore.getBar(),\n *         };\n *       }\n *     },\n *   });\n *\n * On the second calculateState when prevState is not null, the state will be\n * updated to contain the previous foo AND the bar that was just returned. Only\n * returning bar will not delete foo.\n *\n */\n\n\nfunction FluxMixinLegacy(stores) {\n  var options = arguments.length <= 1 || arguments[1] === undefined ? {\n    withProps: false\n  } : arguments[1];\n  stores = stores.filter(function (store) {\n    return !!store;\n  });\n  return {\n    getInitialState: function () {\n      enforceInterface(this);\n      return options.withProps ? this.constructor.calculateState(null, this.props) : this.constructor.calculateState(null, undefined);\n    },\n    componentWillMount: function () {\n      var _this = this; // This tracks when any store has changed and we may need to update.\n\n\n      var changed = false;\n\n      var setChanged = function () {\n        changed = true;\n      }; // This adds subscriptions to stores. When a store changes all we do is\n      // set changed to true.\n\n\n      this._fluxMixinSubscriptions = stores.map(function (store) {\n        return store.addListener(setChanged);\n      }); // This callback is called after the dispatch of the relevant stores. If\n      // any have reported a change we update the state, then reset changed.\n\n      var callback = function () {\n        if (changed) {\n          _this.setState(function (prevState) {\n            return options.withProps ? _this.constructor.calculateState(prevState, _this.props) : _this.constructor.calculateState(prevState, undefined);\n          });\n        }\n\n        changed = false;\n      };\n\n      this._fluxMixinStoreGroup = new FluxStoreGroup(stores, callback);\n    },\n    componentWillUnmount: function () {\n      this._fluxMixinStoreGroup.release();\n\n      for (var _iterator = this._fluxMixinSubscriptions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var subscription = _ref;\n        subscription.remove();\n      }\n\n      this._fluxMixinSubscriptions = [];\n    }\n  };\n}\n\nfunction enforceInterface(o) {\n  !o.constructor.calculateState ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Components that use FluxMixinLegacy must implement ' + '`calculateState()` on the statics object') : invariant(false) : undefined;\n}\n\nmodule.exports = FluxMixinLegacy;","map":{"version":3,"sources":["/Users/jeffreyigims/Documents/survey/node_modules/flux/lib/FluxMixinLegacy.js"],"names":["FluxStoreGroup","require","invariant","FluxMixinLegacy","stores","options","arguments","length","undefined","withProps","filter","store","getInitialState","enforceInterface","constructor","calculateState","props","componentWillMount","_this","changed","setChanged","_fluxMixinSubscriptions","map","addListener","callback","setState","prevState","_fluxMixinStoreGroup","componentWillUnmount","release","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","value","subscription","remove","o","process","env","NODE_ENV","module","exports"],"mappings":"AAAA;;;;;;;;;;AAWA;;AAEA,IAAIA,cAAc,GAAGC,OAAO,CAAC,kBAAD,CAA5B;;AAEA,IAAIC,SAAS,GAAGD,OAAO,CAAC,oBAAD,CAAvB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,SAASE,eAAT,CAAyBC,MAAzB,EAAiC;AAC/B,MAAIC,OAAO,GAAGC,SAAS,CAACC,MAAV,IAAoB,CAApB,IAAyBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAA1C,GAAsD;AAAEC,IAAAA,SAAS,EAAE;AAAb,GAAtD,GAA6EH,SAAS,CAAC,CAAD,CAApG;AAEAF,EAAAA,MAAM,GAAGA,MAAM,CAACM,MAAP,CAAc,UAAUC,KAAV,EAAiB;AACtC,WAAO,CAAC,CAACA,KAAT;AACD,GAFQ,CAAT;AAIA,SAAO;AACLC,IAAAA,eAAe,EAAE,YAAY;AAC3BC,MAAAA,gBAAgB,CAAC,IAAD,CAAhB;AACA,aAAOR,OAAO,CAACI,SAAR,GAAoB,KAAKK,WAAL,CAAiBC,cAAjB,CAAgC,IAAhC,EAAsC,KAAKC,KAA3C,CAApB,GAAwE,KAAKF,WAAL,CAAiBC,cAAjB,CAAgC,IAAhC,EAAsCP,SAAtC,CAA/E;AACD,KAJI;AAMLS,IAAAA,kBAAkB,EAAE,YAAY;AAC9B,UAAIC,KAAK,GAAG,IAAZ,CAD8B,CAG9B;;;AACA,UAAIC,OAAO,GAAG,KAAd;;AACA,UAAIC,UAAU,GAAG,YAAY;AAC3BD,QAAAA,OAAO,GAAG,IAAV;AACD,OAFD,CAL8B,CAS9B;AACA;;;AACA,WAAKE,uBAAL,GAA+BjB,MAAM,CAACkB,GAAP,CAAW,UAAUX,KAAV,EAAiB;AACzD,eAAOA,KAAK,CAACY,WAAN,CAAkBH,UAAlB,CAAP;AACD,OAF8B,CAA/B,CAX8B,CAe9B;AACA;;AACA,UAAII,QAAQ,GAAG,YAAY;AACzB,YAAIL,OAAJ,EAAa;AACXD,UAAAA,KAAK,CAACO,QAAN,CAAe,UAAUC,SAAV,EAAqB;AAClC,mBAAOrB,OAAO,CAACI,SAAR,GAAoBS,KAAK,CAACJ,WAAN,CAAkBC,cAAlB,CAAiCW,SAAjC,EAA4CR,KAAK,CAACF,KAAlD,CAApB,GAA+EE,KAAK,CAACJ,WAAN,CAAkBC,cAAlB,CAAiCW,SAAjC,EAA4ClB,SAA5C,CAAtF;AACD,WAFD;AAGD;;AACDW,QAAAA,OAAO,GAAG,KAAV;AACD,OAPD;;AAQA,WAAKQ,oBAAL,GAA4B,IAAI3B,cAAJ,CAAmBI,MAAnB,EAA2BoB,QAA3B,CAA5B;AACD,KAhCI;AAkCLI,IAAAA,oBAAoB,EAAE,YAAY;AAChC,WAAKD,oBAAL,CAA0BE,OAA1B;;AACA,WAAK,IAAIC,SAAS,GAAG,KAAKT,uBAArB,EAA8CU,QAAQ,GAAGC,KAAK,CAACC,OAAN,CAAcH,SAAd,CAAzD,EAAmFI,EAAE,GAAG,CAAxF,EAA2FJ,SAAS,GAAGC,QAAQ,GAAGD,SAAH,GAAeA,SAAS,CAACK,MAAM,CAACC,QAAR,CAAT,EAAnI,IAAmK;AACjK,YAAIC,IAAJ;;AAEA,YAAIN,QAAJ,EAAc;AACZ,cAAIG,EAAE,IAAIJ,SAAS,CAACvB,MAApB,EAA4B;AAC5B8B,UAAAA,IAAI,GAAGP,SAAS,CAACI,EAAE,EAAH,CAAhB;AACD,SAHD,MAGO;AACLA,UAAAA,EAAE,GAAGJ,SAAS,CAACQ,IAAV,EAAL;AACA,cAAIJ,EAAE,CAACK,IAAP,EAAa;AACbF,UAAAA,IAAI,GAAGH,EAAE,CAACM,KAAV;AACD;;AAED,YAAIC,YAAY,GAAGJ,IAAnB;AAEAI,QAAAA,YAAY,CAACC,MAAb;AACD;;AACD,WAAKrB,uBAAL,GAA+B,EAA/B;AACD;AArDI,GAAP;AAuDD;;AAED,SAASR,gBAAT,CAA0B8B,CAA1B,EAA6B;AAC3B,GAACA,CAAC,CAAC7B,WAAF,CAAcC,cAAf,GAAgC6B,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC5C,SAAS,CAAC,KAAD,EAAQ,wDAAwD,0CAAhE,CAAjD,GAA+JA,SAAS,CAAC,KAAD,CAAxM,GAAkNM,SAAlN;AACD;;AAEDuC,MAAM,CAACC,OAAP,GAAiB7C,eAAjB","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FluxMixinLegacy\n * \n */\n\n'use strict';\n\nvar FluxStoreGroup = require('./FluxStoreGroup');\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * `FluxContainer` should be preferred over this mixin, but it requires using\n * react with classes. So this mixin is provided where it is not yet possible\n * to convert a container to be a class.\n *\n * This mixin should be used for React components that have state based purely\n * on stores. `this.props` will not be available inside of `calculateState()`.\n *\n * This mixin will only `setState` not replace it, so you should always return\n * every key in your state unless you know what you are doing. Consider this:\n *\n *   var Foo = React.createClass({\n *     mixins: [\n *       FluxMixinLegacy([FooStore])\n *     ],\n *\n *     statics: {\n *       calculateState(prevState) {\n *         if (!prevState) {\n *           return {\n *             foo: FooStore.getFoo(),\n *           };\n *         }\n *\n *         return {\n *           bar: FooStore.getBar(),\n *         };\n *       }\n *     },\n *   });\n *\n * On the second calculateState when prevState is not null, the state will be\n * updated to contain the previous foo AND the bar that was just returned. Only\n * returning bar will not delete foo.\n *\n */\nfunction FluxMixinLegacy(stores) {\n  var options = arguments.length <= 1 || arguments[1] === undefined ? { withProps: false } : arguments[1];\n\n  stores = stores.filter(function (store) {\n    return !!store;\n  });\n\n  return {\n    getInitialState: function () {\n      enforceInterface(this);\n      return options.withProps ? this.constructor.calculateState(null, this.props) : this.constructor.calculateState(null, undefined);\n    },\n\n    componentWillMount: function () {\n      var _this = this;\n\n      // This tracks when any store has changed and we may need to update.\n      var changed = false;\n      var setChanged = function () {\n        changed = true;\n      };\n\n      // This adds subscriptions to stores. When a store changes all we do is\n      // set changed to true.\n      this._fluxMixinSubscriptions = stores.map(function (store) {\n        return store.addListener(setChanged);\n      });\n\n      // This callback is called after the dispatch of the relevant stores. If\n      // any have reported a change we update the state, then reset changed.\n      var callback = function () {\n        if (changed) {\n          _this.setState(function (prevState) {\n            return options.withProps ? _this.constructor.calculateState(prevState, _this.props) : _this.constructor.calculateState(prevState, undefined);\n          });\n        }\n        changed = false;\n      };\n      this._fluxMixinStoreGroup = new FluxStoreGroup(stores, callback);\n    },\n\n    componentWillUnmount: function () {\n      this._fluxMixinStoreGroup.release();\n      for (var _iterator = this._fluxMixinSubscriptions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var subscription = _ref;\n\n        subscription.remove();\n      }\n      this._fluxMixinSubscriptions = [];\n    }\n  };\n}\n\nfunction enforceInterface(o) {\n  !o.constructor.calculateState ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Components that use FluxMixinLegacy must implement ' + '`calculateState()` on the statics object') : invariant(false) : undefined;\n}\n\nmodule.exports = FluxMixinLegacy;"]},"metadata":{},"sourceType":"script"}