{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FluxContainer\n * \n */\n'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar FluxContainerSubscriptions = require('./FluxContainerSubscriptions');\n\nvar React = require('react');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar shallowEqual = require('fbjs/lib/shallowEqual');\n\nvar Component = React.Component;\nvar DEFAULT_OPTIONS = {\n  pure: true,\n  withProps: false,\n  withContext: false\n};\n/**\n * A FluxContainer is used to subscribe a react component to multiple stores.\n * The stores that are used must be returned from a static `getStores()` method.\n *\n * The component receives information from the stores via state. The state\n * is generated using a static `calculateState()` method that each container\n * must implement. A simple container may look like:\n *\n *   class FooContainer extends Component {\n *     static getStores() {\n *       return [FooStore];\n *     }\n *\n *     static calculateState() {\n *       return {\n *         foo: FooStore.getState(),\n *       };\n *     }\n *\n *     render() {\n *       return <FooView {...this.state} />;\n *     }\n *   }\n *\n *   module.exports = FluxContainer.create(FooContainer);\n *\n * Flux container also supports some other, more advanced use cases. If you need\n * to base your state off of props as well:\n *\n *   class FooContainer extends Component {\n *     ...\n *\n *     static calculateState(prevState, props) {\n *       return {\n *         foo: FooStore.getSpecificFoo(props.id),\n *       };\n *     }\n *\n *     ...\n *   }\n *\n *   module.exports = FluxContainer.create(FooContainer, {withProps: true});\n *\n * Or if your stores are passed through your props:\n *\n *   class FooContainer extends Component {\n *     ...\n *\n *     static getStores(props) {\n *       const {BarStore, FooStore} = props.stores;\n *       return [BarStore, FooStore];\n *     }\n *\n *     static calculateState(prevState, props) {\n *       const {BarStore, FooStore} = props.stores;\n *       return {\n *         bar: BarStore.getState(),\n *         foo: FooStore.getState(),\n *       };\n *     }\n *\n *     ...\n *   }\n *\n *   module.exports = FluxContainer.create(FooContainer, {withProps: true});\n */\n\nfunction create(Base, options) {\n  enforceInterface(Base); // Construct the options using default, override with user values as necessary.\n\n  var realOptions = _extends({}, DEFAULT_OPTIONS, options || {});\n\n  var getState = function (state, maybeProps, maybeContext) {\n    var props = realOptions.withProps ? maybeProps : undefined;\n    var context = realOptions.withContext ? maybeContext : undefined;\n    return Base.calculateState(state, props, context);\n  };\n\n  var getStores = function (maybeProps, maybeContext) {\n    var props = realOptions.withProps ? maybeProps : undefined;\n    var context = realOptions.withContext ? maybeContext : undefined;\n    return Base.getStores(props, context);\n  }; // Build the container class.\n\n\n  var ContainerClass = function (_Base) {\n    _inherits(ContainerClass, _Base);\n\n    function ContainerClass(props, context) {\n      var _this = this;\n\n      _classCallCheck(this, ContainerClass);\n\n      _Base.call(this, props, context);\n\n      this._fluxContainerSubscriptions = new FluxContainerSubscriptions();\n\n      this._fluxContainerSubscriptions.setStores(getStores(props));\n\n      this._fluxContainerSubscriptions.addListener(function () {\n        _this.setState(function (prevState, currentProps) {\n          return getState(prevState, currentProps, context);\n        });\n      });\n\n      var calculatedState = getState(undefined, props, context);\n      this.state = _extends({}, this.state || {}, calculatedState);\n    } // Make sure we override shouldComponentUpdate only if the pure option is\n    // specified. We can't override this above because we don't want to override\n    // the default behavior on accident. Super works weird with react ES6 classes.\n\n\n    ContainerClass.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {\n      if (_Base.prototype.componentWillReceiveProps) {\n        _Base.prototype.componentWillReceiveProps.call(this, nextProps, nextContext);\n      }\n\n      if (realOptions.withProps || realOptions.withContext) {\n        // Update both stores and state.\n        this._fluxContainerSubscriptions.setStores(getStores(nextProps, nextContext));\n\n        this.setState(function (prevState) {\n          return getState(prevState, nextProps, nextContext);\n        });\n      }\n    };\n\n    ContainerClass.prototype.componentWillUnmount = function componentWillUnmount() {\n      if (_Base.prototype.componentWillUnmount) {\n        _Base.prototype.componentWillUnmount.call(this);\n      }\n\n      this._fluxContainerSubscriptions.reset();\n    };\n\n    return ContainerClass;\n  }(Base);\n\n  var container = realOptions.pure ? createPureComponent(ContainerClass) : ContainerClass; // Update the name of the container before returning\n\n  var componentName = Base.displayName || Base.name;\n  container.displayName = 'FluxContainer(' + componentName + ')';\n  return container;\n}\n\nfunction createPureComponent(BaseComponent) {\n  var PureComponent = function (_BaseComponent) {\n    _inherits(PureComponent, _BaseComponent);\n\n    function PureComponent() {\n      _classCallCheck(this, PureComponent);\n\n      _BaseComponent.apply(this, arguments);\n    }\n\n    PureComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);\n    };\n\n    return PureComponent;\n  }(BaseComponent);\n\n  return PureComponent;\n}\n\nfunction enforceInterface(o) {\n  !o.getStores ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Components that use FluxContainer must implement `static getStores()`') : invariant(false) : undefined;\n  !o.calculateState ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Components that use FluxContainer must implement `static calculateState()`') : invariant(false) : undefined;\n}\n/**\n * This is a way to connect stores to a functional stateless view. Here's a\n * simple example:\n *\n *   // FooView.js\n *\n *   function FooView(props) {\n *     return <div>{props.value}</div>;\n *   }\n *\n *   module.exports = FooView;\n *\n *\n *   // FooContainer.js\n *\n *   function getStores() {\n *     return [FooStore];\n *   }\n *\n *   function calculateState() {\n *     return {\n *       value: FooStore.getState();\n *     };\n *   }\n *\n *   module.exports = FluxContainer.createFunctional(\n *     FooView,\n *     getStores,\n *     calculateState,\n *   );\n *\n */\n\n\nfunction createFunctional(viewFn, _getStores, _calculateState, options) {\n  var FunctionalContainer = function (_Component) {\n    _inherits(FunctionalContainer, _Component);\n\n    function FunctionalContainer() {\n      _classCallCheck(this, FunctionalContainer);\n\n      _Component.apply(this, arguments);\n    } // Update the name of the component before creating the container.\n\n\n    FunctionalContainer.getStores = function getStores(props, context) {\n      return _getStores(props, context);\n    };\n\n    FunctionalContainer.calculateState = function calculateState(prevState, props, context) {\n      return _calculateState(prevState, props, context);\n    };\n\n    FunctionalContainer.prototype.render = function render() {\n      return viewFn(this.state);\n    };\n\n    return FunctionalContainer;\n  }(Component);\n\n  var viewFnName = viewFn.displayName || viewFn.name || 'FunctionalContainer';\n  FunctionalContainer.displayName = viewFnName;\n  return create(FunctionalContainer, options);\n}\n\nmodule.exports = {\n  create: create,\n  createFunctional: createFunctional\n};","map":{"version":3,"sources":["/Users/jeffreyigims/Documents/survey/node_modules/flux/lib/FluxContainer.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","FluxContainerSubscriptions","require","React","invariant","shallowEqual","Component","DEFAULT_OPTIONS","pure","withProps","withContext","Base","options","enforceInterface","realOptions","getState","state","maybeProps","maybeContext","props","undefined","context","calculateState","getStores","ContainerClass","_Base","_this","_fluxContainerSubscriptions","setStores","addListener","setState","prevState","currentProps","calculatedState","componentWillReceiveProps","nextProps","nextContext","componentWillUnmount","reset","container","createPureComponent","componentName","displayName","name","BaseComponent","PureComponent","_BaseComponent","apply","shouldComponentUpdate","nextState","o","process","env","NODE_ENV","createFunctional","viewFn","_getStores","_calculateState","FunctionalContainer","_Component","render","viewFnName","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FluxContainer\n * \n */\n\n'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar FluxContainerSubscriptions = require('./FluxContainerSubscriptions');\nvar React = require('react');\n\nvar invariant = require('fbjs/lib/invariant');\nvar shallowEqual = require('fbjs/lib/shallowEqual');\n\nvar Component = React.Component;\n\nvar DEFAULT_OPTIONS = {\n  pure: true,\n  withProps: false,\n  withContext: false\n};\n\n/**\n * A FluxContainer is used to subscribe a react component to multiple stores.\n * The stores that are used must be returned from a static `getStores()` method.\n *\n * The component receives information from the stores via state. The state\n * is generated using a static `calculateState()` method that each container\n * must implement. A simple container may look like:\n *\n *   class FooContainer extends Component {\n *     static getStores() {\n *       return [FooStore];\n *     }\n *\n *     static calculateState() {\n *       return {\n *         foo: FooStore.getState(),\n *       };\n *     }\n *\n *     render() {\n *       return <FooView {...this.state} />;\n *     }\n *   }\n *\n *   module.exports = FluxContainer.create(FooContainer);\n *\n * Flux container also supports some other, more advanced use cases. If you need\n * to base your state off of props as well:\n *\n *   class FooContainer extends Component {\n *     ...\n *\n *     static calculateState(prevState, props) {\n *       return {\n *         foo: FooStore.getSpecificFoo(props.id),\n *       };\n *     }\n *\n *     ...\n *   }\n *\n *   module.exports = FluxContainer.create(FooContainer, {withProps: true});\n *\n * Or if your stores are passed through your props:\n *\n *   class FooContainer extends Component {\n *     ...\n *\n *     static getStores(props) {\n *       const {BarStore, FooStore} = props.stores;\n *       return [BarStore, FooStore];\n *     }\n *\n *     static calculateState(prevState, props) {\n *       const {BarStore, FooStore} = props.stores;\n *       return {\n *         bar: BarStore.getState(),\n *         foo: FooStore.getState(),\n *       };\n *     }\n *\n *     ...\n *   }\n *\n *   module.exports = FluxContainer.create(FooContainer, {withProps: true});\n */\nfunction create(Base, options) {\n  enforceInterface(Base);\n\n  // Construct the options using default, override with user values as necessary.\n  var realOptions = _extends({}, DEFAULT_OPTIONS, options || {});\n\n  var getState = function (state, maybeProps, maybeContext) {\n    var props = realOptions.withProps ? maybeProps : undefined;\n    var context = realOptions.withContext ? maybeContext : undefined;\n    return Base.calculateState(state, props, context);\n  };\n\n  var getStores = function (maybeProps, maybeContext) {\n    var props = realOptions.withProps ? maybeProps : undefined;\n    var context = realOptions.withContext ? maybeContext : undefined;\n    return Base.getStores(props, context);\n  };\n\n  // Build the container class.\n\n  var ContainerClass = (function (_Base) {\n    _inherits(ContainerClass, _Base);\n\n    function ContainerClass(props, context) {\n      var _this = this;\n\n      _classCallCheck(this, ContainerClass);\n\n      _Base.call(this, props, context);\n      this._fluxContainerSubscriptions = new FluxContainerSubscriptions();\n      this._fluxContainerSubscriptions.setStores(getStores(props));\n      this._fluxContainerSubscriptions.addListener(function () {\n        _this.setState(function (prevState, currentProps) {\n          return getState(prevState, currentProps, context);\n        });\n      });\n      var calculatedState = getState(undefined, props, context);\n      this.state = _extends({}, this.state || {}, calculatedState);\n    }\n\n    // Make sure we override shouldComponentUpdate only if the pure option is\n    // specified. We can't override this above because we don't want to override\n    // the default behavior on accident. Super works weird with react ES6 classes.\n\n    ContainerClass.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {\n      if (_Base.prototype.componentWillReceiveProps) {\n        _Base.prototype.componentWillReceiveProps.call(this, nextProps, nextContext);\n      }\n\n      if (realOptions.withProps || realOptions.withContext) {\n        // Update both stores and state.\n        this._fluxContainerSubscriptions.setStores(getStores(nextProps, nextContext));\n        this.setState(function (prevState) {\n          return getState(prevState, nextProps, nextContext);\n        });\n      }\n    };\n\n    ContainerClass.prototype.componentWillUnmount = function componentWillUnmount() {\n      if (_Base.prototype.componentWillUnmount) {\n        _Base.prototype.componentWillUnmount.call(this);\n      }\n\n      this._fluxContainerSubscriptions.reset();\n    };\n\n    return ContainerClass;\n  })(Base);\n\n  var container = realOptions.pure ? createPureComponent(ContainerClass) : ContainerClass;\n\n  // Update the name of the container before returning\n  var componentName = Base.displayName || Base.name;\n  container.displayName = 'FluxContainer(' + componentName + ')';\n  return container;\n}\n\nfunction createPureComponent(BaseComponent) {\n  var PureComponent = (function (_BaseComponent) {\n    _inherits(PureComponent, _BaseComponent);\n\n    function PureComponent() {\n      _classCallCheck(this, PureComponent);\n\n      _BaseComponent.apply(this, arguments);\n    }\n\n    PureComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);\n    };\n\n    return PureComponent;\n  })(BaseComponent);\n\n  return PureComponent;\n}\n\nfunction enforceInterface(o) {\n  !o.getStores ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Components that use FluxContainer must implement `static getStores()`') : invariant(false) : undefined;\n  !o.calculateState ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Components that use FluxContainer must implement `static calculateState()`') : invariant(false) : undefined;\n}\n\n/**\n * This is a way to connect stores to a functional stateless view. Here's a\n * simple example:\n *\n *   // FooView.js\n *\n *   function FooView(props) {\n *     return <div>{props.value}</div>;\n *   }\n *\n *   module.exports = FooView;\n *\n *\n *   // FooContainer.js\n *\n *   function getStores() {\n *     return [FooStore];\n *   }\n *\n *   function calculateState() {\n *     return {\n *       value: FooStore.getState();\n *     };\n *   }\n *\n *   module.exports = FluxContainer.createFunctional(\n *     FooView,\n *     getStores,\n *     calculateState,\n *   );\n *\n */\nfunction createFunctional(viewFn, _getStores, _calculateState, options) {\n  var FunctionalContainer = (function (_Component) {\n    _inherits(FunctionalContainer, _Component);\n\n    function FunctionalContainer() {\n      _classCallCheck(this, FunctionalContainer);\n\n      _Component.apply(this, arguments);\n    }\n\n    // Update the name of the component before creating the container.\n\n    FunctionalContainer.getStores = function getStores(props, context) {\n      return _getStores(props, context);\n    };\n\n    FunctionalContainer.calculateState = function calculateState(prevState, props, context) {\n      return _calculateState(prevState, props, context);\n    };\n\n    FunctionalContainer.prototype.render = function render() {\n      return viewFn(this.state);\n    };\n\n    return FunctionalContainer;\n  })(Component);\n\n  var viewFnName = viewFn.displayName || viewFn.name || 'FunctionalContainer';\n  FunctionalContainer.displayName = viewFnName;\n  return create(FunctionalContainer, options);\n}\n\nmodule.exports = { create: create, createFunctional: createFunctional };"]},"metadata":{},"sourceType":"script"}