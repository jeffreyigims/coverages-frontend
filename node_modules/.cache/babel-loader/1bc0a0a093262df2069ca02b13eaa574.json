{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FluxReduceStore\n * \n */\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar FluxStore = require('./FluxStore');\n\nvar abstractMethod = require('./abstractMethod');\n\nvar invariant = require('fbjs/lib/invariant');\n/**\n * This is the basic building block of a Flux application. All of your stores\n * should extend this class.\n *\n *   class CounterStore extends FluxReduceStore<number> {\n *     getInitialState(): number {\n *       return 1;\n *     }\n *\n *     reduce(state: number, action: Object): number {\n *       switch(action.type) {\n *         case: 'add':\n *           return state + action.value;\n *         case: 'double':\n *           return state * 2;\n *         default:\n *           return state;\n *       }\n *     }\n *   }\n */\n\n\nvar FluxReduceStore = function (_FluxStore) {\n  _inherits(FluxReduceStore, _FluxStore);\n\n  function FluxReduceStore(dispatcher) {\n    _classCallCheck(this, FluxReduceStore);\n\n    _FluxStore.call(this, dispatcher);\n\n    this._state = this.getInitialState();\n  }\n  /**\n   * Getter that exposes the entire state of this store. If your state is not\n   * immutable you should override this and not expose _state directly.\n   */\n\n\n  FluxReduceStore.prototype.getState = function getState() {\n    return this._state;\n  };\n  /**\n   * Constructs the initial state for this store. This is called once during\n   * construction of the store.\n   */\n\n\n  FluxReduceStore.prototype.getInitialState = function getInitialState() {\n    return abstractMethod('FluxReduceStore', 'getInitialState');\n  };\n  /**\n   * Used to reduce a stream of actions coming from the dispatcher into a\n   * single state object.\n   */\n\n\n  FluxReduceStore.prototype.reduce = function reduce(state, action) {\n    return abstractMethod('FluxReduceStore', 'reduce');\n  };\n  /**\n   * Checks if two versions of state are the same. You do not need to override\n   * this if your state is immutable.\n   */\n\n\n  FluxReduceStore.prototype.areEqual = function areEqual(one, two) {\n    return one === two;\n  };\n\n  FluxReduceStore.prototype.__invokeOnDispatch = function __invokeOnDispatch(action) {\n    this.__changed = false; // Reduce the stream of incoming actions to state, update when necessary.\n\n    var startingState = this._state;\n    var endingState = this.reduce(startingState, action); // This means your ending state should never be undefined.\n\n    !(endingState !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s returned undefined from reduce(...), did you forget to return ' + 'state in the default case? (use null if this was intentional)', this.constructor.name) : invariant(false) : undefined;\n\n    if (!this.areEqual(startingState, endingState)) {\n      this._state = endingState; // `__emitChange()` sets `this.__changed` to true and then the actual\n      // change will be fired from the emitter at the end of the dispatch, this\n      // is required in order to support methods like `hasChanged()`\n\n      this.__emitChange();\n    }\n\n    if (this.__changed) {\n      this.__emitter.emit(this.__changeEvent);\n    }\n  };\n\n  return FluxReduceStore;\n}(FluxStore);\n\nmodule.exports = FluxReduceStore;","map":{"version":3,"sources":["/Users/jeffreyigims/Documents/survey/node_modules/flux/lib/FluxReduceStore.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","FluxStore","require","abstractMethod","invariant","FluxReduceStore","_FluxStore","dispatcher","call","_state","getInitialState","getState","reduce","state","action","areEqual","one","two","__invokeOnDispatch","__changed","startingState","endingState","undefined","process","env","NODE_ENV","name","__emitChange","__emitter","emit","__changeEvent","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FluxReduceStore\n * \n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar FluxStore = require('./FluxStore');\n\nvar abstractMethod = require('./abstractMethod');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * This is the basic building block of a Flux application. All of your stores\n * should extend this class.\n *\n *   class CounterStore extends FluxReduceStore<number> {\n *     getInitialState(): number {\n *       return 1;\n *     }\n *\n *     reduce(state: number, action: Object): number {\n *       switch(action.type) {\n *         case: 'add':\n *           return state + action.value;\n *         case: 'double':\n *           return state * 2;\n *         default:\n *           return state;\n *       }\n *     }\n *   }\n */\n\nvar FluxReduceStore = (function (_FluxStore) {\n  _inherits(FluxReduceStore, _FluxStore);\n\n  function FluxReduceStore(dispatcher) {\n    _classCallCheck(this, FluxReduceStore);\n\n    _FluxStore.call(this, dispatcher);\n    this._state = this.getInitialState();\n  }\n\n  /**\n   * Getter that exposes the entire state of this store. If your state is not\n   * immutable you should override this and not expose _state directly.\n   */\n\n  FluxReduceStore.prototype.getState = function getState() {\n    return this._state;\n  };\n\n  /**\n   * Constructs the initial state for this store. This is called once during\n   * construction of the store.\n   */\n\n  FluxReduceStore.prototype.getInitialState = function getInitialState() {\n    return abstractMethod('FluxReduceStore', 'getInitialState');\n  };\n\n  /**\n   * Used to reduce a stream of actions coming from the dispatcher into a\n   * single state object.\n   */\n\n  FluxReduceStore.prototype.reduce = function reduce(state, action) {\n    return abstractMethod('FluxReduceStore', 'reduce');\n  };\n\n  /**\n   * Checks if two versions of state are the same. You do not need to override\n   * this if your state is immutable.\n   */\n\n  FluxReduceStore.prototype.areEqual = function areEqual(one, two) {\n    return one === two;\n  };\n\n  FluxReduceStore.prototype.__invokeOnDispatch = function __invokeOnDispatch(action) {\n    this.__changed = false;\n\n    // Reduce the stream of incoming actions to state, update when necessary.\n    var startingState = this._state;\n    var endingState = this.reduce(startingState, action);\n\n    // This means your ending state should never be undefined.\n    !(endingState !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s returned undefined from reduce(...), did you forget to return ' + 'state in the default case? (use null if this was intentional)', this.constructor.name) : invariant(false) : undefined;\n\n    if (!this.areEqual(startingState, endingState)) {\n      this._state = endingState;\n\n      // `__emitChange()` sets `this.__changed` to true and then the actual\n      // change will be fired from the emitter at the end of the dispatch, this\n      // is required in order to support methods like `hasChanged()`\n      this.__emitChange();\n    }\n\n    if (this.__changed) {\n      this.__emitter.emit(this.__changeEvent);\n    }\n  };\n\n  return FluxReduceStore;\n})(FluxStore);\n\nmodule.exports = FluxReduceStore;"]},"metadata":{},"sourceType":"script"}